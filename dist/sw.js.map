{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/js/sw/index.js","node_modules/serviceworker-cache-polyfill/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sw.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\r\n * Copyright 2015 Google Inc. All rights reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\n\r\nrequire('serviceworker-cache-polyfill');\r\n\r\nvar version = 'v15';\r\nvar staticCacheName = 'trains-static-v15';\r\n\r\nself.oninstall = function(event) {\r\n  self.skipWaiting();\r\n\r\n  event.waitUntil(\r\n    caches.open(staticCacheName).then(function(cache) {\r\n      return cache.addAll([\r\n        './',\r\n        'css/all.css',\r\n        'js/page.js',\r\n        'imgs/logo.svg',\r\n        'imgs/icon.png'\r\n      ]);\r\n    })\r\n  );\r\n};\r\n\r\nvar expectedCaches = [\r\n  staticCacheName,\r\n  'trains-imgs',\r\n  'trains-data'\r\n];\r\n\r\nself.onactivate = function(event) {\r\n  if (self.clients && clients.claim) {\r\n    clients.claim();\r\n  }\r\n\r\n  // remove caches beginning \"trains-\" that aren't in\r\n  // expectedCaches\r\n  event.waitUntil(\r\n    caches.keys().then(function(cacheNames) {\r\n      return Promise.all(\r\n        cacheNames.map(function(cacheName) {\r\n          if (/^trains-/.test(cacheName) && expectedCaches.indexOf(cacheName) == -1) {\r\n            return caches.delete(cacheName);\r\n          }\r\n        })\r\n      );\r\n    })\r\n  );\r\n};\r\n\r\nself.onfetch = function(event) {\r\n  var requestURL = new URL(event.request.url);\r\n\r\n  if (requestURL.hostname == 'api.flickr.com') {\r\n    event.respondWith(flickrAPIResponse(event.request));\r\n  }\r\n  else if (/\\.staticflickr\\.com$/.test(requestURL.hostname)) {\r\n    event.respondWith(flickrImageResponse(event.request));\r\n  }\r\n  else {\r\n    event.respondWith(\r\n      caches.match(event.request, {\r\n        ignoreVary: true\r\n      })\r\n    );\r\n  }\r\n};\r\n\r\nfunction getPhotoURL(photo) {\r\n  return 'https://farm' + photo.farm + '.staticflickr.com/' + photo.server + '/' + photo.id + '_' + photo.secret + '_c.jpg';\r\n}\r\n\r\nfunction flickrAPIResponse(request) {\r\n  if (request.headers.get('x-use-cache-only')) {\r\n    return caches.match(request);\r\n  }\r\n  else if (request.headers.get('x-cache-warmup')) {\r\n    var headers = new Headers(request.headers);\r\n    headers.delete('x-cache-warmup');\r\n    return flickrAPIResponse(new Request(request, {headers: headers})).then(function(response) {\r\n      return response.json();\r\n    }).then(function(data) {\r\n      var imgRequests = data.photos.photo.map(getPhotoURL).map(function(url) {\r\n        return new Request(url, {mode: 'no-cors'});\r\n      });\r\n      return Promise.all(imgRequests.map(flickrImageResponse));\r\n    }).then(function() {\r\n      return caches.match(request);\r\n    });\r\n  }\r\n  else {\r\n    return fetch(request).then(function(response) {\r\n      return caches.open('trains-data').then(function(cache) {\r\n        // clean up the image cache\r\n        Promise.all([\r\n          response.clone().json(),\r\n          caches.open('trains-imgs')\r\n        ]).then(function(results) {\r\n          var data = results[0];\r\n          var imgCache = results[1];\r\n\r\n          var imgURLs = data.photos.photo.map(getPhotoURL);\r\n\r\n          // if an item in the cache *isn't* in imgURLs, delete it\r\n          imgCache.keys().then(function(requests) {\r\n            requests.forEach(function(request) {\r\n              if (imgURLs.indexOf(request.url) == -1) {\r\n                imgCache.delete(request);\r\n              }\r\n            });\r\n          });\r\n        });\r\n\r\n        cache.put(request, response.clone());\r\n\r\n        return response;\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nfunction flickrImageResponse(request) {\r\n  return caches.match(request).then(function(response) {\r\n    if (response) {\r\n      return response;\r\n    }\r\n\r\n    return fetch(request).then(function(response) {\r\n      caches.open('trains-imgs').then(function(cache) {\r\n        cache.put(request, response);\r\n      });\r\n\r\n      return response.clone();\r\n    });\r\n  });\r\n}\r\n","if (!Cache.prototype.add) {\n  Cache.prototype.add = function add(request) {\n    return this.addAll([request]);\n  };\n}\n\nif (!Cache.prototype.addAll) {\n  Cache.prototype.addAll = function addAll(requests) {\n    var cache = this;\n\n    // Since DOMExceptions are not constructable:\n    function NetworkError(message) {\n      this.name = 'NetworkError';\n      this.code = 19;\n      this.message = message;\n    }\n    NetworkError.prototype = Object.create(Error.prototype);\n\n    return Promise.resolve().then(function() {\n      if (arguments.length < 1) throw new TypeError();\n      \n      // Simulate sequence<(Request or USVString)> binding:\n      var sequence = [];\n\n      requests = requests.map(function(request) {\n        if (request instanceof Request) {\n          return request;\n        }\n        else {\n          return String(request); // may throw TypeError\n        }\n      });\n\n      return Promise.all(\n        requests.map(function(request) {\n          if (typeof request === 'string') {\n            request = new Request(request);\n          }\n\n          var scheme = new URL(request.url).protocol;\n\n          if (scheme !== 'http:' && scheme !== 'https:') {\n            throw new NetworkError(\"Invalid scheme\");\n          }\n\n          return fetch(request.clone());\n        })\n      );\n    }).then(function(responses) {\n      // TODO: check that requests don't overwrite one another\n      // (don't think this is possible to polyfill due to opaque responses)\n      return Promise.all(\n        responses.map(function(response, i) {\n          return cache.put(requests[i], response);\n        })\n      );\n    }).then(function() {\n      return undefined;\n    });\n  };\n}\n"]}